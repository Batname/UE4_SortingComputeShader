//Since we can't #include private Engine shaders such as Common.ush we have to copy the needed Shaders from the Engine' Shader directory.
//When this gets chaned in the future, we could change this to #include "/Engine/Private/Common.ush".
#include "/Engine/Private/Common.ush"

////////////////////////////
// Bitonic Sort
// Compute Shader
// by Valentin Kraft 
///
// Inspired by the ComputeShaderSort11
// example by Microsoft. 
///////////////////////////// 

//#define BITONIC_BLOCK_SIZE 32 
//#define TRANSPOSE_BLOCK_SIZE 16 

//--------------------------------------------------------------------------------------
// Constant Buffers
//--------------------------------------------------------------------------------------
//cbuffer CB : register(b0)
//{
//    unsigned int g_iLevel;
//    unsigned int g_iLevelMask;
//    unsigned int g_iWidth;
//    unsigned int g_iHeight;
//};

RWTexture2D<float4> OutputSurface;      //UAV Texture
Texture2D<float4> PointPosTex;          //Read-Only Point Position Texture

// Thread group shared memory limit (DX11): 32KB --> 2048 float4 values --> 32 thread groups optimum --> 1024 Threads optimum (?)
// Only shared within a thread group!

bool getBit(uint i, uint n)
{
    return ((n >> i) & 1) == 1;
}

#define THREADX 32
#define THREADY 32
#define c_width 256

#define GROUP_THREADS THREADX * THREADY
groupshared uint o[GROUP_THREADS];
groupshared uint e[GROUP_THREADS];
groupshared uint f[GROUP_THREADS];
//groupshared uint t[GROUP_THREADS];
groupshared uint d[GROUP_THREADS];
groupshared uint totalFalses;



// In order to make full use of the resources of the GPU, there should be at least as many thread groups as there are multiprocessors on the GPU, and ideally two or more #ToDo: Make dynamic
// Max number of threads in a group (DX11): 1024
[numthreads(THREADX, THREADY, 1)]
void MainComputeShader(uint3 Gid : SV_GroupID,              //atm: -, 0...256, - in rows (Y)        --> current group index (dispatched by c++)
                        uint3 DTid : SV_DispatchThreadID,   //atm: 0...256 in rows & columns (XY)   --> "global" thread id
                        uint3 GTid : SV_GroupThreadID,      //atm: 0...256, -,- in columns (X)      --> current threadId in group / "local" threadId
                        uint GI : SV_GroupIndex)            //atm: 0...256 in columns (X)           --> "flattened" index of a thread within a group
{
	//Set up some variables we are going to need
	float sizeX, sizeY;
	OutputSurface.GetDimensions(sizeX, sizeY);
    const float4 camPos = float4(0.0, 0.0, 0.0, 0.0); // #Temp
    float4 pointPos = PointPosTex.Load(int3(DTid.xy, 0));



	// index out of structured buffer input
    //uint idx = DTid.x + DTid.y * c_width;

	// populate the o array with the uint versions of this block
    o[GI] = uint(distance(pointPos, camPos) * 0xFFFFFFFF);


	// loop through each bit
	[unroll(64)]                    // Wert?!
    for (int n = 0; n < 64; n++)    // Wert?!
    {

		// e is 1 where the nth bit is 0.
        e[GI] = getBit(n, o[GI]) == 0;

        GroupMemoryBarrierWithGroupSync(); // wait for e to be populated so we can random access it

        if (GI != 0)
        {
            f[GI] = e[GI - 1];
        }
        else
        {
            f[GI] = 0;
        }

        GroupMemoryBarrierWithGroupSync(); // wait for f to be populated before we loop on it

		// Scan Operation (AKA Prefix Sum)
		[unroll(int(log2(GROUP_THREADS)))]
        for (uint i = 1; i < GROUP_THREADS; i <<= 1)
        { //for n = 0 .. log2(N), i =  2^n
            uint temp;
            if (GI > i)
            {
                temp = f[GI] + f[GI - i];
            }
            else
            {
                temp = f[GI];
            }
            GroupMemoryBarrierWithGroupSync();
            f[GI] = temp;
            GroupMemoryBarrierWithGroupSync();

        }

		// Sum up the falses
        if (GI == 0)
        {
            totalFalses = e[GROUP_THREADS - 1] + f[GROUP_THREADS - 1];
        }

        GroupMemoryBarrierWithGroupSync(); // wait for thread 0 to finish

		// t contains the indexes for the 1 bits
		//t[GI] = GI - f[GI] + totalFalses;

		// we now construct t on the fly

		// d contains the destination indexes for all the bits
        d[GI] = e[GI] ? f[GI] : GI - f[GI] + totalFalses;

		// get the variable
        uint temp = o[GI];

        GroupMemoryBarrierWithGroupSync(); // read-before-write

		// rewrite o
        o[d[GI]] = temp;

        GroupMemoryBarrierWithGroupSync(); // wait for o to be fully populated

    }

    OutputSurface[DTid.xy] = float(o[GI]) / 0xFFFFFFFF;
    
    // Visualise thread layout
    OutputSurface[DTid.xy] = float(o[GI]) / 0xFFFFFFFF + float4((float3) GTid, 0) / 256;



	/*
	uint mod = GI % 16;
	
	if (mod == 0 || GI < 16) {
		Result[DTid.xy] = float4(1, 0, 0, 1);
	}
	*/

}

